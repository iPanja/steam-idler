/* ui_xml.h is generated by running make. It can be targeted specifically with `make source/ui_xml.h` */
#include <gtk/gtk.h>
#include <stdlib.h>
#include <assert.h>

#include <windows.h>
#include <stdio.h>
#include <tchar.h>

#include "library.c"


/* The macros VERSION, NAME, TARGET, AUTHOR and COPYRIGHT are available for this program to reference
information about itself. These macros are defined in config.mk*/

typedef struct{
        unsigned long app_id;
        PROCESS_INFORMATION pi;
        bool isActive;
}IdleProcess, PtrIdleProcess;

static GtkWidget*  window;
static GtkImage *game1_image;
static GtkBox *game_box;
static GtkEntry *add_game_entry;
static GtkListBox *game_listbox;
GtkWidget *add_game_window;

static IdleProcess *procs = NULL;
static int procs_size = 0;
static unsigned long *library = NULL;
static int library_size = 0;

const int rowCount = 3;


//Functional prototypes
G_MODULE_EXPORT gboolean on_rbutton_enter_notify_event(GtkWidget *widget);
G_MODULE_EXPORT gboolean on_rbutton_leave_notify_event(GtkWidget *widget);
G_MODULE_EXPORT gboolean on_rbutton_click_event(GtkButton *self, gpointer user_data);


//https://stackoverflow.com/questions/1636333/download-file-using-libcurl-in-c-c
size_t write_data(void *ptr, size_t size, size_t nmemb, FILE *stream) {
    size_t written = fwrite(ptr, size, nmemb, stream);
    return written;
}

void set_image(GtkImage *image, char *filepath, int width, int height){
        //Load image into GtkImage
        GError *error = NULL;
        GdkPixbuf *pixbuf= gdk_pixbuf_new_from_file_at_size(filepath, width, height, &error);
        if(pixbuf == NULL){
                g_printerr ("Error loading file: #%d %s\n", error->code, error->message);
                g_error_free (error);
                exit(1);
        }
        gtk_image_set_from_pixbuf(image, pixbuf);
}
void set_hero(GtkImage *image, char *filepath){
        set_image(image, filepath, 480, 160);
}
void set_icon(GtkImage *image, char *filepath){
        //Default icon size is 32x32 pixels
        set_image(image, filepath, 32, 32);
}
void run_process(unsigned long app_id){
        //Allocate space in *procs
        IdleProcess *temp = realloc(procs, ++procs_size * sizeof(IdleProcess));
        procs = temp;

        //Create new process (WINDOWS)
        char cmd[32];
        snprintf(cmd, sizeof(cmd), "si.exe %lu -1", app_id);

        STARTUPINFO si;
        PROCESS_INFORMATION pi;
        memset(&si, 0, sizeof(si));
        si.cb = sizeof(si);
        memset(&pi, 0, sizeof(pi));

        if(!CreateProcess(
                NULL,
                cmd,
                NULL,
                NULL,
                FALSE,
                CREATE_NO_WINDOW,
                NULL,
                NULL,
                &si,
                &pi)
        ){
                printf("Failed to create idle process (%d)\n", GetLastError());
                return;
        }

        //Append to proc array
        IdleProcess *proc = malloc(sizeof(PtrIdleProcess));
        proc->app_id = app_id;
        proc->pi = pi;
        proc->isActive = true;
        procs[procs_size-1] = *proc;
}
void close_process(IdleProcess *proc){
        if(proc->isActive){
                TerminateProcess(proc->pi.hProcess, 0);
                CloseHandle(proc->pi.hProcess);
                CloseHandle(proc->pi.hThread);
                proc->isActive = false;
        }
}
void idle_game(unsigned long app_id){
        //Create frame with hero image
        char frame_label[16];
        snprintf(frame_label, sizeof(frame_label), "Game: %lu", app_id);
        GtkFrame *frame = GTK_FRAME(gtk_frame_new(frame_label));
        GtkImage *hero_image = GTK_IMAGE(gtk_image_new());
        GtkOverlay *overlay = GTK_OVERLAY(gtk_overlay_new());
        GtkButton *overlay_button = GTK_BUTTON(gtk_button_new_with_label("KILL"));
        gtk_widget_set_opacity(GTK_WIDGET(overlay_button), 0);
        char *hero_path;
        
        //STRUCTURE
        //ListBoxRow (automatically created  when using list_box_prepend)
        //      Overlay
        //              Frame
        //                      Image
        //                      Label (Game: APP_ID)
        //              OVERLAY: Button
        if(get_game_hero(app_id, &hero_path)){
                set_hero(hero_image, hero_path);
                gtk_container_add(GTK_CONTAINER(frame), GTK_WIDGET(hero_image));
                gtk_container_add(GTK_CONTAINER(overlay), GTK_WIDGET(frame));
                gtk_overlay_add_overlay(overlay, GTK_WIDGET(overlay_button));

                //Hookup events for the remove button to display properly when hovering
                g_signal_connect(G_OBJECT(overlay_button), "enter-notify-event", G_CALLBACK(on_rbutton_enter_notify_event), G_OBJECT(overlay_button));
                g_signal_connect(G_OBJECT(overlay_button), "leave-notify-event", G_CALLBACK(on_rbutton_leave_notify_event), G_OBJECT(overlay_button));
                unsigned long *s_app_id = malloc(sizeof(unsigned long));
                *s_app_id = app_id;
                g_signal_connect(G_OBJECT(overlay_button), "clicked", G_CALLBACK(on_rbutton_click_event), (gpointer) s_app_id);

                //Add row to listbox (row object is automatically created with this method)
                gtk_list_box_prepend(game_listbox, GTK_WIDGET(overlay));
                //Show
                gtk_widget_show(GTK_WIDGET(frame));
                gtk_widget_show(GTK_WIDGET(hero_image));
                gtk_widget_show(GTK_WIDGET(overlay));
                gtk_widget_show(GTK_WIDGET(overlay_button));
        }else{
                printf("Could NOT get game hero\n");
        }
        //Start new process to idle game
        run_process(app_id); //Auto registers it in the static global variable, procs
}

// EVENT LISTENERS
G_MODULE_EXPORT void on_mw_add_game_button_clicked(){
        GtkBuilder *builder;

        builder = gtk_builder_new_from_file("ui.glade");
        add_game_window = GTK_WIDGET(gtk_builder_get_object(builder, "add_game_window"));
        add_game_entry = GTK_ENTRY(gtk_builder_get_object(builder, "add_game_entry"));
        gtk_builder_connect_signals(builder, NULL);
        
        
        //Populate images
        GtkListBox *listbox;
        listbox = GTK_LIST_BOX(gtk_builder_get_object(builder, "add_game_listbox"));

        for(int i = 0; i < library_size; i++){
                unsigned long id = library[i];
                GtkImage *image = GTK_IMAGE(gtk_image_new());
                char *icon_path;
                if(get_game_icon(id, &icon_path)){
                        set_icon(image, icon_path);
                        //gtk_list_box_prepend(listbox, GTK_WIDGET(image));
                        gtk_list_box_insert(listbox, GTK_WIDGET(image), i);
                        gtk_widget_show(GTK_WIDGET(image));
                }
                free(icon_path);
        }


        //Show
        gtk_builder_connect_signals(builder, add_game_window);
        g_object_unref(builder);
        gtk_widget_show(add_game_window);
        
}

G_MODULE_EXPORT int on_add_game_listbox_row_selected(GtkListBox *listbox, GtkListBoxRow *row, gpointer user_data){
        int index = gtk_list_box_row_get_index(row);
        if(add_game_entry){
                char app_id_str[8];
                snprintf(app_id_str, sizeof(app_id_str), "%lu", library[index]);
                gtk_entry_set_text(add_game_entry, app_id_str);
        }
}
G_MODULE_EXPORT int on_add_game_button_clicked(){
        //Get APP_ID to idle
        unsigned long app_id = strtoul(gtk_entry_get_text(add_game_entry), NULL, 0);
        //Cleanup add_game_window
        gtk_window_close(GTK_WINDOW(add_game_window));
        //Idle game
        idle_game(app_id);
}

G_MODULE_EXPORT gboolean on_rbutton_enter_notify_event(GtkWidget *widget){
        gtk_widget_set_opacity(widget, 0.75);
}
G_MODULE_EXPORT gboolean on_rbutton_leave_notify_event(GtkWidget *widget){
        gtk_widget_set_opacity(widget, 0);
}
G_MODULE_EXPORT gboolean on_rbutton_click_event(GtkButton *self, gpointer user_data){
        //Remove from UI
        unsigned long app_id = *((unsigned long *) user_data);
        //Remove the ListBoxRow (the parent of the button passed as red->widget)
        gtk_widget_destroy(GTK_WIDGET(gtk_widget_get_parent(GTK_WIDGET(self))));

        //End process
        //Loop through all processes and close the ones with the matching app_id
        for(int i = 0; i < procs_size; i++){
                IdleProcess *proc = &procs[i];
                if(proc->app_id == app_id && proc->isActive){
                        close_process(proc);
                }
        }

        //Cleanup
        free(user_data); //Was originally malloced
}

int main(int argc, char* argv[]){
        GtkBuilder* builder;

        gtk_init(&argc, &argv);

        builder = gtk_builder_new_from_file("ui.glade");
        window = GTK_WIDGET(gtk_builder_get_object(builder, "window_main"));
        //gtk_builder_connect_signals(builder, NULL);

        game1_image = GTK_IMAGE(gtk_builder_get_object(builder, "game1_image"));
        game_box = GTK_BOX(gtk_builder_get_object(builder, "game_box"));
        game_listbox = GTK_LIST_BOX(gtk_builder_get_object(builder, "game_listbox"));
        get_installed_app_ids(&library, &library_size); //Load games
        
        //Event mask
        gtk_widget_add_events(GTK_WIDGET(window), GDK_ALL_EVENTS_MASK);

        //Connect signals
        gtk_builder_connect_signals(builder, window);
        g_signal_connect(G_OBJECT(window), "destroy", G_CALLBACK(gdk_window_destroy), GTK_WINDOW(window));

        g_object_unref(builder);
        gtk_widget_show(window);

        //Set csgo image
        //set_hero(game1_image, "csgo_hero.jpg");

        gtk_main();
        return 0;
}

void on_window_main_destroy()
{
        free(library);
        //Close all existing processes
        for(int i = 0; i < procs_size; i++){
                close_process(&procs[i]);
        }
        free(procs);
        gtk_main_quit();
        g_application_quit(G_APPLICATION(window));
}