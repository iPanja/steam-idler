/* ui_xml.h is generated by running make. It can be targeted specifically with `make source/ui_xml.h` */
#include <gtk/gtk.h>
#include <stdlib.h>
#include <assert.h>
#include <time.h>

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <tlhelp32.h>
#include <processthreadsapi.h>

#include "library.c"

__declspec(dllimport) BOOL __cdecl SteamAPI_Init(); //Windows import

/* The macros VERSION, NAME, TARGET, AUTHOR and COPYRIGHT are available for this program to reference
information about itself. These macros are defined in config.mk*/

typedef struct{
        unsigned long app_id;
        PROCESS_INFORMATION pi;
        time_t start_time;
        guint event_source_id;
        bool isActive;
        bool isRelaunching;
}IdleProcess, PtrIdleProcess;

static GtkWidget*  window;
static GtkImage *game1_image;
static GtkBox *game_box;
static GtkEntry *add_game_entry;
static GtkListBox *game_listbox;
static GtkLabel *steam_status_label;
static bool lost_steam_connection;
GtkWidget *add_game_window;

static IdleProcess *procs = NULL;
static int procs_size = 0;
static unsigned long *library = NULL;
static int library_size = 0;

const int rowCount = 3;


//Functional prototypes
G_MODULE_EXPORT gboolean on_rbutton_enter_notify_event(GtkWidget *widget);
G_MODULE_EXPORT gboolean on_rbutton_leave_notify_event(GtkWidget *widget);
G_MODULE_EXPORT gboolean on_rbutton_click_event(GtkButton *self, gpointer user_data);
gboolean on_timeout(gpointer user_data);
gboolean on_window_main_destroy();


//https://stackoverflow.com/questions/1636333/download-file-using-libcurl-in-c-c
size_t write_data(void *ptr, size_t size, size_t nmemb, FILE *stream) {
    size_t written = fwrite(ptr, size, nmemb, stream);
    return written;
}

//https://stackoverflow.com/questions/13179410/check-whether-one-specific-process-is-running-on-windows-with-chttps://stackoverflow.com/questions/13179410/check-whether-one-specific-process-is-running-on-windows-with-c
DWORD FindProcessId(char* processName)
{
    // strip path

    char* p = strrchr(processName, '\\');
    if(p)
        processName = p+1;

    PROCESSENTRY32 processInfo;
    processInfo.dwSize = sizeof(processInfo);

    HANDLE processesSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if ( processesSnapshot == INVALID_HANDLE_VALUE )
        return 0;

    Process32First(processesSnapshot, &processInfo);
    if ( !strcmp(processName, processInfo.szExeFile) )
    {
        CloseHandle(processesSnapshot);
        return processInfo.th32ProcessID;
    }

    while ( Process32Next(processesSnapshot, &processInfo) )
    {
        if ( !strcmp(processName, processInfo.szExeFile) )
        {
          CloseHandle(processesSnapshot);
          return processInfo.th32ProcessID;
        }
    }

    CloseHandle(processesSnapshot);
    return 0;
}

bool is_steam_connected(){
        return FindProcessId("steam.exe") != 0;
}

void set_image(GtkImage *image, char *filepath, int width, int height){
        //Load image into GtkImage
        GError *error = NULL;
        GdkPixbuf *pixbuf= gdk_pixbuf_new_from_file_at_size(filepath, width, height, &error);
        if(pixbuf == NULL){
                g_printerr ("Error loading file: #%d %s\n", error->code, error->message);
                g_error_free (error);
                exit(1);
        }
        gtk_image_set_from_pixbuf(image, pixbuf);
}
void set_hero(GtkImage *image, char *filepath){
        set_image(image, filepath, 480, 160);
}
void set_icon(GtkImage *image, char *filepath){
        //Default icon size is 32x32 pixels
        set_image(image, filepath, 32, 32);
}
bool _create_process(unsigned long app_id, PROCESS_INFORMATION *process_information){
        char cmd[32];
        snprintf(cmd, sizeof(cmd), "si.exe %lu -1", app_id);

        STARTUPINFO si;
        PROCESS_INFORMATION pi;
        memset(&si, 0, sizeof(si));
        si.cb = sizeof(STARTUPINFO);
        memset(&pi, 0, sizeof(pi));

        if(CreateProcess(
                NULL,
                cmd,
                NULL,
                NULL,
                FALSE,
                CREATE_NO_WINDOW,
                NULL,
                NULL,
                &si,
                &pi)
        ){
                *process_information = pi;
                return true;
        }
        return false;
}

void run_process(unsigned long app_id, guint event_source_id){
        //Allocate space in *procs
        IdleProcess *temp = realloc(procs, ++procs_size * sizeof(IdleProcess));
        procs = temp;

        //Create new process (WINDOWS)
        PROCESS_INFORMATION pi;
        if(!_create_process(app_id, &pi)){
                printf("Failed to create process for APP ID: %lu\n", app_id);
                return;
        }

        //Append to proc array
        IdleProcess *proc = malloc(sizeof(PtrIdleProcess));
        proc->app_id = app_id;
        proc->pi = pi;
        proc->start_time = time(NULL);
        proc->event_source_id = event_source_id;
        proc->isActive = true;
        proc->isRelaunching = false;
        procs[procs_size-1] = *proc;
}
void close_process(IdleProcess *proc){
        if(proc->isActive || proc->isRelaunching){
                TerminateProcess(proc->pi.hProcess, 0);
                CloseHandle(proc->pi.hProcess);
                CloseHandle(proc->pi.hThread);
                //Release time timer timeout
                g_source_remove(proc->event_source_id);
                proc->isActive = false;
        }
}
void idle_game(unsigned long app_id){
        //Create frame with hero image
        char frame_label[16];
        snprintf(frame_label, sizeof(frame_label), "Game: %lu", app_id);
        GtkFrame *frame = GTK_FRAME(gtk_frame_new(frame_label));
        GtkImage *hero_image = GTK_IMAGE(gtk_image_new());
        GtkOverlay *overlay = GTK_OVERLAY(gtk_overlay_new());
        GtkButton *overlay_button = GTK_BUTTON(gtk_button_new_with_label("KILL"));
        gtk_widget_set_opacity(GTK_WIDGET(overlay_button), 0);
        char *hero_path;
        
        //STRUCTURE
        //ListBoxRow (automatically created  when using list_box_prepend)
        //      Overlay
        //              Frame
        //                      Image
        //                      Label (Game: APP_ID)
        //              OVERLAY: Button
        if(locate_app_id_hero_path(app_id, &hero_path)){
                set_hero(hero_image, hero_path);
                gtk_container_add(GTK_CONTAINER(frame), GTK_WIDGET(hero_image));
                gtk_container_add(GTK_CONTAINER(overlay), GTK_WIDGET(frame));
                gtk_overlay_add_overlay(overlay, GTK_WIDGET(overlay_button));

                //Hookup events for the remove button to display properly when hovering
                g_signal_connect(G_OBJECT(overlay_button), "enter-notify-event", G_CALLBACK(on_rbutton_enter_notify_event), G_OBJECT(overlay_button));
                g_signal_connect(G_OBJECT(overlay_button), "leave-notify-event", G_CALLBACK(on_rbutton_leave_notify_event), G_OBJECT(overlay_button));
                unsigned long *s_app_id = malloc(sizeof(unsigned long));
                *s_app_id = app_id;
                g_signal_connect(G_OBJECT(overlay_button), "clicked", G_CALLBACK(on_rbutton_click_event), (gpointer) s_app_id);
                //Periodically call a function to update the timer being displayed in the frame's label
                guint event_source_id = g_timeout_add_seconds(1, on_timeout, frame);

                //Add row to listbox (row object is automatically created with this method)
                gtk_list_box_prepend(game_listbox, GTK_WIDGET(overlay));
                //Show
                gtk_widget_show(GTK_WIDGET(frame));
                gtk_widget_show(GTK_WIDGET(hero_image));
                gtk_widget_show(GTK_WIDGET(overlay));
                gtk_widget_show(GTK_WIDGET(overlay_button));

                //Start new process to idle game
                run_process(app_id, event_source_id); //Auto registers it in the static global variable, procs
        }else{
                printf("Could NOT get game hero\n");
                return;
        }
}
void relaunch_idler(IdleProcess *proc){
         //Close existing idler process
        TerminateProcess(proc->pi.hProcess, 0);
        CloseHandle(proc->pi.hProcess);
        CloseHandle(proc->pi.hThread);
        //Create new idler process for the same APP ID
        _create_process(proc->app_id, &(proc->pi)); //Attach process to existing IdleProcess instance
        proc->start_time = time(NULL); //Reset the timer
}
void relaunch_idlers(){
        for(int i = 0; i < procs_size; i++){
                relaunch_idler(&(procs[i]));
        }
}

// EVENT LISTENERS
G_MODULE_EXPORT void on_mw_add_game_button_clicked(){
        GtkBuilder *builder;

        builder = gtk_builder_new_from_file("ui.glade");
        add_game_window = GTK_WIDGET(gtk_builder_get_object(builder, "add_game_window"));
        add_game_entry = GTK_ENTRY(gtk_builder_get_object(builder, "add_game_entry"));
        gtk_builder_connect_signals(builder, NULL);
        //gtk_window_set_destroy_with_parent(add_game_window, true);

        
        
        //Populate images
        GtkListBox *listbox;
        listbox = GTK_LIST_BOX(gtk_builder_get_object(builder, "add_game_listbox"));

        for(int i = 0; i < library_size; i++){
                unsigned long id = library[i];
                GtkImage *image = GTK_IMAGE(gtk_image_new());
                char *icon_path;
                if(locate_app_id_icon_path(id, &icon_path)){
                        set_icon(image, icon_path);
                        //gtk_list_box_prepend(listbox, GTK_WIDGET(image));
                        gtk_list_box_insert(listbox, GTK_WIDGET(image), i);
                        gtk_widget_show(GTK_WIDGET(image));
                }
                free(icon_path);
        }


        //Show
        gtk_builder_connect_signals(builder, add_game_window);
        g_object_unref(builder);
        gtk_widget_show(add_game_window);
        
}

G_MODULE_EXPORT int on_add_game_listbox_row_selected(GtkListBox *listbox, GtkListBoxRow *row, gpointer user_data){
        int index = gtk_list_box_row_get_index(row);
        if(add_game_entry){
                char app_id_str[8];
                snprintf(app_id_str, sizeof(app_id_str), "%lu", library[index]);
                gtk_entry_set_text(add_game_entry, app_id_str);
        }
}
G_MODULE_EXPORT int on_add_game_button_clicked(){
        //Get APP_ID to idle
        unsigned long app_id = strtoul(gtk_entry_get_text(add_game_entry), NULL, 0);
        //Cleanup add_game_window
        gtk_window_close(GTK_WINDOW(add_game_window));
        //Idle game
        idle_game(app_id);
}

G_MODULE_EXPORT gboolean on_rbutton_enter_notify_event(GtkWidget *widget){
        gtk_widget_set_opacity(widget, 0.75);
}
G_MODULE_EXPORT gboolean on_rbutton_leave_notify_event(GtkWidget *widget){
        gtk_widget_set_opacity(widget, 0);
}
G_MODULE_EXPORT gboolean on_rbutton_click_event(GtkButton *self, gpointer user_data){
        //Remove from UI
        unsigned long app_id = *((unsigned long *) user_data);

        //End process
        //Loop through all processes and close the ones with the matching app_id
        for(int i = 0; i < procs_size; i++){
                IdleProcess *proc = &procs[i];
                if(proc->app_id == app_id && proc->isActive){
                        close_process(proc);
                }
        }

        //Remove the ListBoxRow (the parent of the button passed as red->widget)
        gtk_widget_destroy(GTK_WIDGET(gtk_widget_get_parent(GTK_WIDGET(self))));

        //Cleanup
        free(user_data); //Was originally malloced
}

gboolean attempt_idler_relaunch(gpointer user_data){
        printf("Attempting to relaunch process now\n");
        IdleProcess *proc = (IdleProcess *) user_data;

        if(is_steam_connected()){
                relaunch_idler(proc);
                proc->isRelaunching = false;
        }else{
                //Dont requeue this method, it should be called in the future
        }
        return false; //This method should only be run once, returning false will cancel subsequent attempted calls
}

gboolean on_timeout(gpointer user_data){
        //If steam connection has been lost, do not update timer display
        if(lost_steam_connection)
                return true; //Returning false would cancel subsequent on_timeout calls, we still want to wait for the chance they relaunch Steam
        
        
        //Get frame to update
        GtkFrame *frame = GTK_FRAME(user_data);

        //Extract APP ID from frame's label
        const char *frame_label = gtk_frame_get_label(frame);
        char label[32];
        strcpy(label, frame_label);
        strtok(label, " ");
        unsigned long app_id = strtoul(strtok(NULL, " "), NULL, 0); //After already calling strtok once, this second call will return the app_id (as a string)


        //Locate the frame's corresponding IdleProcess to find its start time and calculate the idle duration
        double duration;
        for(int i = 0; i < procs_size; i++){
                if(procs[i].isActive && procs[i].app_id == app_id){
                        duration = difftime(time(NULL), procs[i].start_time);

                        //Double check and make sure that the process is still running
                        //This case would probably fail if we re-started an idler process before Steam fully initialized
                        //If an idler process (si.exe) fails to connect to Steam (SteamAPI_INIT fails), the process will close
                        DWORD lpExitCode = 0;
                        //If the app is supposed to be running (isActive) but we receive an error while checking the process' status, relaunch it soon (AND IDLER IS NOT CURRENTLY BEING RELAUNCHED)
                        printf("Checking status...\n");
                        if(!procs[i].isRelaunching && (GetExitCodeProcess(procs[i].pi.hProcess, &lpExitCode) == 0 || lpExitCode != STILL_ACTIVE)){
                                //Attempt relaunch in 10 seconds
                                printf("Last error: %ld\n", GetLastError());
                                printf("Exit Code: %ld\n", lpExitCode);
                                procs[i].isRelaunching = true;
                                g_timeout_add_seconds(10, attempt_idler_relaunch, &procs[i]);
                        }
                }
        }

        //Update the frame's label with the new idle duration
        char new_label[32];
        snprintf(new_label, sizeof(new_label), "Game: %lu (%02d:%02d:%02d)", app_id, (int) duration/3600, ((int) duration/60) % 60, (int) duration % 60);
        gtk_frame_set_label(frame, new_label);

        return true;
}
gboolean on_timeout_steam_status(){
        printf("Checking steam status...\n");
        GtkStyleContext *ctx = gtk_widget_get_style_context(GTK_WIDGET(steam_status_label));
        if(is_steam_connected()){
                gtk_label_set_label(steam_status_label, "Steam connected!");
                gtk_style_context_remove_class(ctx, "redLabelStyle");
                gtk_style_context_add_class(ctx, "greenLabelStyle");

                //We have connection to steam now, if we previously lost it then relaunch all idlers
                if(lost_steam_connection){
                        relaunch_idlers();
                        lost_steam_connection = false;
                }
        }else{
                gtk_label_set_label(steam_status_label, "Steam not connected!");
                gtk_style_context_remove_class(ctx, "greenLabelStyle");
                gtk_style_context_add_class(ctx, "redLabelStyle");

                lost_steam_connection = true;
        }
        return true;
}

int main(int argc, char* argv[]){
        GtkBuilder* builder;

        gtk_init(&argc, &argv);

        builder = gtk_builder_new_from_file("ui.glade");
        window = GTK_WIDGET(gtk_builder_get_object(builder, "window_main"));
        //gtk_builder_connect_signals(builder, NULL);

        game1_image = GTK_IMAGE(gtk_builder_get_object(builder, "game1_image"));
        game_box = GTK_BOX(gtk_builder_get_object(builder, "game_box"));
        game_listbox = GTK_LIST_BOX(gtk_builder_get_object(builder, "game_listbox"));
        steam_status_label = GTK_LABEL(gtk_builder_get_object(builder, "steam_status_label"));
        get_installed_app_ids(&library, &library_size); //Load games
        
        //Event mask
        gtk_widget_add_events(GTK_WIDGET(window), GDK_ALL_EVENTS_MASK);

        //Set CSS
        GtkCssProvider *provider = gtk_css_provider_new();
        gtk_css_provider_load_from_path(provider, "main.css", NULL);
        gtk_style_context_add_provider_for_screen (gdk_screen_get_default(), GTK_STYLE_PROVIDER(provider), GTK_STYLE_PROVIDER_PRIORITY_USER);

        //Periodically check if steam is connected properly
        on_timeout_steam_status();
        g_timeout_add_seconds(10, on_timeout_steam_status, NULL);

        //Connect signals
        gtk_builder_connect_signals(builder, window);
        g_signal_connect(G_OBJECT(window), "destroy", G_CALLBACK(on_window_main_destroy), NULL);

        g_object_unref(builder);
        gtk_widget_show(window);

        //Set csgo image
        //set_hero(game1_image, "csgo_hero.jpg");

        gtk_main();
        return 0;
}

gboolean on_window_main_destroy()
{       
        //Close all existing processes
        for(int i = 0; i < procs_size; i++){
                close_process(&(procs[i]));
        }
        //Cleanup
        free(library);
        free(procs);
        gtk_main_quit();

        return true;
}